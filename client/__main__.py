import argparse
from asyncio import get_event_loop
import os
import sys
from typing import Callable

from client.receiver import Receiver
from client.sender import Sender
from client.utils.communication import SessionConfig
from client.utils.file import get_human_readable_file_size


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Simple peer-to-peer file transfer CLI app")
    subparsers = parser.add_subparsers(dest="command")

    parser.add_argument(
        "-c", "--chunk-size-bytes",
        type=int,
        help="Chunk (message) size in bytes. Default: 16384 (16 kB)",
        default=16384,
    )
    parser.add_argument(
        "-s", "--server-address",
        type=str,
        help="Signaling server address. Default: 'ws://95.155.71.82:25565'",
        default="ws://95.155.71.82:25565",
    )

    receive_parser = subparsers.add_parser(
        "receive",
        help="Use sender-generated hash to receive file(s)",
    )
    receive_parser.add_argument(
        "hash",
        type=str, nargs=1, help="Session name (hash generated by sender)",
    )
    receive_parser.add_argument(
        "--max-ram-usage", "-m",
        type=int,
        nargs="?",
        help="RAM usage limit (MB). Default: 2000",
        default=500,
    )

    send_parser = subparsers.add_parser(
        "send",
        help="Start file transfer session and generate hash for receiver",
    )
    send_parser.add_argument(
        "files",
        type=str, nargs='+', help="File(s) to send",
    )

    return parser.parse_args()


if __name__ == "__main__":
    args = parse_args()
    session_config = SessionConfig(server_address=args.server_address, chunk_size_bytes=args.chunk_size_bytes)

    if args.command == "receive":
        if args.max_ram_usage < session_config.chunk_size_megabytes():
            print(f"RAM usage limit (MB) cannot be lower than the current chunk size: {get_human_readable_file_size(session_config.CHUNK_SIZE_BYTES)}")
            sys.exit(1)

        action: Callable = Receiver(session_name=args.hash[0], max_ram_mb=args.max_ram_usage, session_config=session_config)
    elif args.command == "send":
        non_existent_files = list(filter(lambda file: not os.path.exists(file), args.files))
        if non_existent_files:
            print(f"The following files do not exist: {non_existent_files}")
            sys.exit(1)

        action: Callable = Sender(file_paths=args.files, session_config=session_config)
    else:
        print("Invalid command")
        sys.exit(1)

    get_event_loop().run_until_complete(action())
